<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ReplicatedRegistry2 Docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for ReplicatedRegistry2 - A client-server synchronized table registry module for Roblox">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ReplicatedRegistry2 Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/athar-adv/ReplicatedRegistry2" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>ReplicatedRegistry2 is a client-server synchronized table registry module for Roblox that provides two-way data replication with built-in filtering, change tracking, and automatic synchronization.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Two-way synchronization</strong> between server and clients</li>
<li><strong>Change tracking</strong> with automatic diff calculation</li>
<li><strong>Built-in filters</strong> for access control and rate limiting</li>
<li><strong>Commit/revert system</strong> for managing changes</li>
<li><strong>Proxy interface</strong> for clean, chainable API</li>
<li><strong>Custom callbacks</strong> for validation and security</li>
</ul>
<h2 id="basic-concept"><a class="header" href="#basic-concept">Basic Concept</a></h2>
<p>ReplicatedRegistry2 maintains a registry of tables that can be synchronized between server and clients. Each registered table:</p>
<ul>
<li>Has a unique key for identification</li>
<li>Tracks changes automatically</li>
<li>Can be replicated with filters</li>
<li>Supports both direct and proxy access patterns</li>
</ul>
<h2 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h2>
<ul>
<li>Player data synchronization</li>
<li>Shared game state (leaderboards, settings)</li>
<li>Real-time collaborative data</li>
<li>Any data that needs server-client sync with validation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Place the ReplicatedRegistry2 module in <code>ReplicatedStorage</code> or <code>ServerScriptService</code> depending on your project structure.</p>
<h2 id="remote-setup"><a class="header" href="#remote-setup">Remote Setup</a></h2>
<p>ReplicatedRegistry2 requires two remotes for communication:</p>
<pre><code class="language-lua">-- In ReplicatedStorage
local RequestFullRemote = Instance.new("RemoteFunction")
RequestFullRemote.Name = "RequestFull"
RequestFullRemote.Parent = ReplicatedStorage

local SendChangesRemote = Instance.new("RemoteEvent")
SendChangesRemote.Name = "SendChanges"
SendChangesRemote.Parent = ReplicatedStorage
</code></pre>
<h2 id="server-configuration"><a class="header" href="#server-configuration">Server Configuration</a></h2>
<pre><code class="language-lua">local ReplicatedRegistry = require(ReplicatedStorage.ReplicatedRegistry2)

-- Option 1: Using RemoteInstances directly
ReplicatedRegistry.server.set_remote_instances(
    ReplicatedStorage.RequestFullRemote,
    ReplicatedStorage.SendChangesRemote
)

-- Option 2: Using custom callbacks (allows you to do modifications before send/recieve)
ReplicatedRegistry.server.set_remote_callbacks(
    function(handler)
        -- Initialize request handler
        ReplicatedStorage.RequestFullRemote.OnServerInvoke = handler
    end,
    function(player, key, changes)
        -- Send changes to client
        ReplicatedStorage.SendChangesRemote:FireClient(player, key, changes)
    end,
    function(receiver)
        -- Connect change receiver
        ReplicatedStorage.SendChangesRemote.OnServerEvent:Connect(receiver)
    end
)
</code></pre>
<h2 id="client-configuration"><a class="header" href="#client-configuration">Client Configuration</a></h2>
<pre><code class="language-lua">local ReplicatedRegistry = require(ReplicatedStorage.ReplicatedRegistry2)

-- Option 1: Using RemoteInstances directly
ReplicatedRegistry.client.set_remote_instances(
    ReplicatedStorage.RequestFullRemote,
    ReplicatedStorage.SendChangesRemote
)

-- Option 2: Using custom callbacks (allows you to do modifications before send/recieve)
ReplicatedRegistry.client.set_remote_callbacks(
    function(key)
        -- Request full table
        return ReplicatedStorage.RequestFullRemote:InvokeServer(key)
    end,
    function(key, changes)
        -- Send changes to server
        ReplicatedStorage.SendChangesRemote:FireServer(key, changes)
    end,
    function(receiver)
        -- Connect change receiver
        ReplicatedStorage.SendChangesRemote.OnClientEvent:Connect(receiver)
    end
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-api"><a class="header" href="#shared-api">Shared API</a></h1>
<h2 id="change-management"><a class="header" href="#change-management">Change Management</a></h2>
<h3 id="get_changeskey-any---"><a class="header" href="#get_changeskey-any---"><code>get_changes(key: any) -&gt; ()</code></a></h3>
<p>Gets all pending changes since last commit.</p>
<pre><code class="language-lua">local changes = ReplicatedRegistry.get_changes("player_123")
-- changes = {{v = 150, p = {"coins"}}, {v = 2, p = {"level"}}}
</code></pre>
<h3 id="commit_changeskey-any-changes-tablechanges---"><a class="header" href="#commit_changeskey-any-changes-tablechanges---"><code>commit_changes(key: any, changes: TableChanges?) -&gt; ()</code></a></h3>
<p>Commits changes, updating the internal copy.</p>
<pre><code class="language-lua">ReplicatedRegistry.commit_changes("player_123")
</code></pre>
<h3 id="revert_changeskey-any-changes-tablechanges---"><a class="header" href="#revert_changeskey-any-changes-tablechanges---"><code>revert_changes(key: any, changes: TableChanges?) -&gt; ()</code></a></h3>
<p>Reverts uncommitted changes.</p>
<pre><code class="language-lua">local data = ReplicatedRegistry.server.await_view("player_123")
data.coins = 999 -- Oops, mistake

ReplicatedRegistry.revert_changes("player_123")
-- coins reverted to previous committed value
</code></pre>
<h2 id="util"><a class="header" href="#util">Util</a></h2>
<h3 id="get_registered_keys---any"><a class="header" href="#get_registered_keys---any"><code>get_registered_keys() -&gt; {any}</code></a></h3>
<p>Returns an array of currently registered register keys. Useful for mass replication of keys</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-api"><a class="header" href="#server-api">Server API</a></h1>
<h2 id="registering-tables"><a class="header" href="#registering-tables">Registering Tables</a></h2>
<h3 id="serverregisterkey-any-table-table-filter-replicationfilter"><a class="header" href="#serverregisterkey-any-table-table-filter-replicationfilter"><code>server.register(key: any, table: Table, filter: ReplicationFilter?)</code></a></h3>
<p>Registers a table on the server for replication.</p>
<pre><code class="language-luau">local playerData = {
    coins = 100,
    level = 1,
    inventory = {}
}

server.register("player_123", playerData)
</code></pre>
<p><strong>With filter:</strong></p>
<pre><code class="language-luau">local filter = ReplicatedRegistry.get_filter({
    rate_limit = 10, -- 10 changes per second max
    player_whitelist = {123, 456} -- Only these user IDs
})

server.register("shared_data", sharedTable, filter)
</code></pre>
<h3 id="serverderegisterregister_key-any-_auto_replicate-boolean"><a class="header" href="#serverderegisterregister_key-any-_auto_replicate-boolean"><code>server.deregister(register_key: any, _auto_replicate: boolean?)</code></a></h3>
<p>Deregisters a table on the server, if already registered.
If <code>_auto_replicate</code> is set to false, then clients won't know the key has been deregistered until the next time it is replicated.</p>
<h2 id="accessing-tables"><a class="header" href="#accessing-tables">Accessing Tables</a></h2>
<h3 id="serverviewkey-any---view"><a class="header" href="#serverviewkey-any---view"><code>server.view(key: any) -&gt; View</code></a></h3>
<p>Returns a viewing interface for registree data.</p>
<pre><code class="language-lua">local data = server.view("player_123")
    .unwrap()
assert(data, "data not registered!")
data.coins = 150
data.level = 2
</code></pre>
<pre><code class="language-luau">local proxy = server.view("player_123")
    .as_proxy()
    .await()

-- Set values
proxy.set({"coins"}, 200)
proxy.set({"inventory", "sword"}, true)

-- Get values
local coins = proxy.get({"coins"})

-- Increment values
proxy.incr({"coins"}, 50)
proxy.incr({"level"}, 1)

-- Replicate to specific players
proxy.replicate({player1, player2})

-- Replicate to all players
proxy.replicate()

-- Get full table
local fullTable = proxy.data()
</code></pre>
<h2 id="replication"><a class="header" href="#replication">Replication</a></h2>
<h3 id="serverto_clientskey-any-players-player-_sender-sender_server-_changes-tablechanges-_auto_commit-boolean---"><a class="header" href="#serverto_clientskey-any-players-player-_sender-sender_server-_changes-tablechanges-_auto_commit-boolean---"><code>server.to_clients(key: any, players: {Player}, _sender: Sender_Server?, _changes: TableChanges?, _auto_commit: boolean?) -&gt; ()</code></a></h3>
<p>Sends changes to specified clients.</p>
<pre><code class="language-lua">-- Replicate to specific players
ReplicatedRegistry.server.to_clients(
    "player_123",
    {player1, player2}
)

-- Replicate to all players
ReplicatedRegistry.server.to_clients(
    "global_data",
    game.Players:GetPlayers()
)
</code></pre>
<h2 id="listening-for-changes"><a class="header" href="#listening-for-changes">Listening for Changes</a></h2>
<h3 id="on_receivekey-any-callback-sender-player-old_table-table-changes-tablechanges------scriptconnection"><a class="header" href="#on_receivekey-any-callback-sender-player-old_table-table-changes-tablechanges------scriptconnection"><code>on_receive(key: any, callback: (sender: Player, old_table: Table, changes: TableChanges) -&gt; ()) -&gt; ScriptConnection</code></a></h3>
<p>Listens for incoming changes from a client.</p>
<pre><code class="language-luau">local connection = ReplicatedRegistry.client.on_receive("player_123", function(sender, table, changes)
    print(`From {sender.Name}`)
    for _, change in changes do
        print("Path:", table.concat(change.p, "."))
        print("Value:", change.v)
    end
end)

-- Disconnect when done
connection:Disconnect()
</code></pre>
<h3 id="on_key_changedkey-any-path-any-callback-sender-player-old_value-any-new_value-any------scriptconnection"><a class="header" href="#on_key_changedkey-any-path-any-callback-sender-player-old_value-any-new_value-any------scriptconnection"><code>on_key_changed(key: any, path: {any}, callback: (sender: Player, old_value: any, new_value: any) -&gt; ()) -&gt; ScriptConnection</code></a></h3>
<p>Listens for incoming changes to a specific path from a client.</p>
<pre><code class="language-luau">local connection = ReplicatedRegistry.client.on_key_changed("player_123", {"coins"}, function(sender, old_value, new_value)
    print(`{old_value} -&gt; {new_value} from {sender.Name}`)
end)

-- Disconnect when done
connection:Disconnect()
</code></pre>
<h3 id="on_updateregister_key-string-fn-sender-player-data-table------scriptconnection"><a class="header" href="#on_updateregister_key-string-fn-sender-player-data-table------scriptconnection"><code>on_update(register_key: string, fn: (sender: Player, data: Table) -&gt; ()) -&gt; ScriptConnection</code></a></h3>
<p>Listens for applied changes incoming from a client. Differs from on_receive in that the changes are already applied to the data when the callback is called</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-api"><a class="header" href="#client-api">Client API</a></h1>
<h2 id="accessing-tables-1"><a class="header" href="#accessing-tables-1">Accessing Tables</a></h2>
<h3 id="clientviewkey-any---view"><a class="header" href="#clientviewkey-any---view"><code>client.view(key: any) -&gt; View</code></a></h3>
<p>Returns a viewing interface for registree data on the server.</p>
<pre><code class="language-luau">local playerData = ReplicatedRegistry.client.view("player_123")
    .unwrap()
assert(playerData, "playerData not registered yet!")
print(playerData.coins) -- 100

-- Modify locally
playerData.coins = 150
</code></pre>
<pre><code class="language-luau">local playerData = ReplicatedRegistry.client.view("player_123")
    .await()
print(playerData.coins) -- 100
</code></pre>
<pre><code class="language-luau">local proxy = ReplicatedRegistry.client.view("player_123")
    .as_proxy()
    .await()
assert(proxy, "proxy not registered yet!")

-- Set values
proxy.set({"coins"}, 200)
proxy.set({"inventory", "sword"}, true)

-- Get values
local coins = proxy.get({"coins"})

-- Increment values
proxy.incr({"coins"}, 50)

-- Replicate changes to server
proxy.replicate()

-- Get full table
local fullTable = proxy.data()
</code></pre>
<h2 id="replication-1"><a class="header" href="#replication-1">Replication</a></h2>
<h3 id="clientto_serverkey-any-sender-sender_client-changes-tablechanges-auto_commit-boolean---"><a class="header" href="#clientto_serverkey-any-sender-sender_client-changes-tablechanges-auto_commit-boolean---"><code>client.to_server(key: any, sender: Sender_Client?, changes: TableChanges?, auto_commit: boolean?) -&gt; ()</code></a></h3>
<p>Sends changes to the server.</p>
<pre><code class="language-luau">local data = ReplicatedRegistry.client.view("player_123")
    .await()
data.coins = 200
data.level = 5

-- Send changes to server
ReplicatedRegistry.client.to_server("player_123")
</code></pre>
<p><strong>Manual change tracking:</strong></p>
<pre><code class="language-luau">local data = ReplicatedRegistry.client.view("player_123")
    .await()
data.coins = 200

local changes = ReplicatedRegistry.get_changes("player_123")
ReplicatedRegistry.client.to_server("player_123", nil, changes)
</code></pre>
<h2 id="listening-for-changes-1"><a class="header" href="#listening-for-changes-1">Listening for Changes</a></h2>
<h3 id="on_receivekey-any-callback-old_table-table-changes-tablechanges------scriptconnection"><a class="header" href="#on_receivekey-any-callback-old_table-table-changes-tablechanges------scriptconnection"><code>on_receive(key: any, callback: (old_table: Table, changes: TableChanges) -&gt; ()) -&gt; ScriptConnection</code></a></h3>
<p>Listens for incoming changes from the server.</p>
<pre><code class="language-luau">local connection = ReplicatedRegistry.client.on_receive("player_123", function(table, changes)
    for _, change in changes do
        print("Path:", table.concat(change.p, "."))
        print("Value:", change.v)
    end
end)

-- Disconnect when done
connection:Disconnect()
</code></pre>
<h3 id="on_key_changedkey-any-path-any-callback-old_value-any-new_value-any------scriptconnection"><a class="header" href="#on_key_changedkey-any-path-any-callback-old_value-any-new_value-any------scriptconnection"><code>on_key_changed(key: any, path: {any}, callback: (old_value: any, new_value: any) -&gt; ()) -&gt; ScriptConnection</code></a></h3>
<p>Listens for incoming changes to a specific path from the server.</p>
<pre><code class="language-luau">local connection = ReplicatedRegistry.client.on_key_changed("player_123", {"coins"}, function(old_value, new_value)
    print(`{old_value} -&gt; {new_value}`)
end)

-- Disconnect when done
connection:Disconnect()
</code></pre>
<h3 id="on_updateregister_key-string-fn-data-table------scriptconnection"><a class="header" href="#on_updateregister_key-string-fn-data-table------scriptconnection"><code>on_update(register_key: string, fn: (data: Table) -&gt; ()) -&gt; ScriptConnection</code></a></h3>
<p>Listens for applied changes incoming from the server. Differs from on_receive in that the changes are already applied to the data when the callback is called</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filters"><a class="header" href="#filters">Filters</a></h1>
<p>Filters are a on-recieved per register key validation system everytime your context recieves TableChanges from the opposite context.</p>
<h2 id="built-in-filters"><a class="header" href="#built-in-filters">Built-in Filters</a></h2>
<h3 id="player_blacklist"><a class="header" href="#player_blacklist"><code>player_blacklist</code></a></h3>
<p>Blocks specific user IDs from sending changes.</p>
<pre><code class="language-lua">local filter = ReplicatedRegistry.get_filter({
    player_blacklist = {123456, 789012}
})

ReplicatedRegistry.server.register("data", myTable, filter)
</code></pre>
<h3 id="player_whitelist"><a class="header" href="#player_whitelist"><code>player_whitelist</code></a></h3>
<p>Only allows specific user IDs to send changes.</p>
<pre><code class="language-lua">local filter = ReplicatedRegistry.get_filter({
    player_whitelist = {123456, 789012}
})

ReplicatedRegistry.server.register("admin_data", adminTable, filter)
</code></pre>
<h3 id="rate_limit"><a class="header" href="#rate_limit"><code>rate_limit</code></a></h3>
<p>Limits how many changes per second can be received.</p>
<pre><code class="language-lua">local filter = ReplicatedRegistry.get_filter({
    rate_limit = 5 -- Max 5 changes per second
})

ReplicatedRegistry.server.register("data", myTable, filter)
</code></pre>
<h3 id="no_recieve"><a class="header" href="#no_recieve"><code>no_recieve</code></a></h3>
<p>Prevents receiving changes entirely (send-only).</p>
<pre><code class="language-lua">local filter = ReplicatedRegistry.get_filter({
    no_recieve = true
})

ReplicatedRegistry.server.register("readonly_data", myTable, filter)
</code></pre>
<h2 id="custom-filters"><a class="header" href="#custom-filters">Custom Filters</a></h2>
<p>You can use custom validation logic.</p>
<pre><code class="language-lua">local function filter(sender, register_key, tbl, changes)
    -- Only allow owner to modify their own data
    if sender.UserId ~= register_key then
        return false
    end
    for _, c in changes do
        local path, value = c.p, c.v
        -- Only allow positive coin values
        if path[1] == "coins" and value &lt; 0 then
            return false
        end
    end
    
    return true
end

ReplicatedRegistry.server.register("player_data", data, filter)
</code></pre>
<h2 id="combining-filters"><a class="header" href="#combining-filters">Combining Filters</a></h2>
<p>You can combine multiple filters together into a composite filter using <code>get_filter()</code>.</p>
<pre><code class="language-lua">local filter = ReplicatedRegistry.get_filter({
    player_whitelist = {123456, 789012},
    rate_limit = 10,
    custom = function(sender, _, _, changes)
        for _, c in changes do
            -- Additional validation
            if type(value) ~= "number" then return false end
        end
        return true
    end
})
</code></pre>
<h2 id="composite-filter-behavior"><a class="header" href="#composite-filter-behavior">Composite Filter Behavior</a></h2>
<ul>
<li>All filters in a composite filter must pass for a change to be accepted</li>
<li>If <code>custom</code> filter is provided, it runs after built-in filters</li>
<li>If any filter returns <code>false</code>, the change is rejected</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h1>
<p>Callbacks allow you to customize behavior at key points in the replication process.</p>
<h2 id="global-callbacks"><a class="header" href="#global-callbacks">Global Callbacks</a></h2>
<h3 id="on_changes_recieved"><a class="header" href="#on_changes_recieved"><code>on_changes_recieved</code></a></h3>
<p>Called whenever changes are received from a remote.</p>
<pre><code class="language-lua">ReplicatedRegistry.callbacks.on_changes_recieved = function(sender, register_key, changes)
    -- sender: Player who sent (nil on client)
    -- register_key: The key of the registree
    -- changes: Array of changes
    
    print(`Received {#changes} changes for {register_key}`)
    
    -- Return values:
    -- "pass" - Continue normal processing
    -- "return" - Stop processing, don't apply changes
    -- "disable" - Disable this key entirely
    
    return "pass"
end
</code></pre>
<p><strong>With validation:</strong></p>
<pre><code class="language-lua">ReplicatedRegistry.callbacks.on_changes_recieved = function(sender, register_key, changes)
    -- Validate changes
    for _, change in changes do
        if not isValidChange(change) then
            return "disable", "Invalid change detected"
        end
    end
    
    return "pass"
end
</code></pre>
<h3 id="on_key_disabled"><a class="header" href="#on_key_disabled"><code>on_key_disabled</code></a></h3>
<p>Called when a key is disabled due to an error or validation failure.</p>
<pre><code class="language-lua">ReplicatedRegistry.callbacks.on_key_disabled = function(register_key, reason)
    warn(`Key {register_key} was disabled: {reason}`)
    
    -- Clean up or notify admins
    notifyAdmins(register_key, reason)
end
</code></pre>
<h2 id="server-callbacks"><a class="header" href="#server-callbacks">Server Callbacks</a></h2>
<h3 id="validate_full_request"><a class="header" href="#validate_full_request"><code>validate_full_request</code></a></h3>
<p>Validates whether a client can request the full table.</p>
<pre><code class="language-lua">ReplicatedRegistry.server.callbacks.validate_full_request = function(player, key)
    -- Check if player owns this data
    if type(key) == "number" then
        return player.UserId == key
    end
    
    -- Check if key contains player's UserId
    if type(key) == "string" then
        return string.find(key, tostring(player.UserId)) ~= nil
    end
    
    return true
end
</code></pre>
<p><strong>Default behavior:</strong></p>
<p>The default callback includes rate limiting and UserId validation:</p>
<pre><code class="language-lua">-- Default implementation
on_request_with_validate_key = function(plr, key)
    -- Rate limit: 5 requests per second
    if not replication_filters.rate_limit(5)(plr) then 
        return false 
    end
    
    -- Wait up to 5 seconds for key to exist
    for i = 1, 5 do
        if registrees[key] then break end
        task.wait(1)
    end
    
    -- Validate ownership
    if type(key) == "number" then
        return plr.UserId == key
    end
    if type(key) == "string" then
        return string.find(key, tostring(plr.UserId)) ~= nil
    end
    
    return false
end
</code></pre>
<h2 id="custom-default-callbacks"><a class="header" href="#custom-default-callbacks">Custom Default Callbacks</a></h2>
<p>You can restore default callbacks if needed:</p>
<pre><code class="language-lua">-- Use default callbacks
ReplicatedRegistry.server.callbacks.validate_full_request = 
    ReplicatedRegistry.default_callbacks.on_request

ReplicatedRegistry.callbacks.on_changes_recieved = 
    ReplicatedRegistry.default_callbacks.on_changes_recieved
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-reference"><a class="header" href="#types-reference">Types Reference</a></h1>
<p>Type definitions for ReplicatedRegistry2.</p>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="table"><a class="header" href="#table"><code>Table</code></a></h3>
<pre><code class="language-luau">export type Table = {[any]: any}
</code></pre>
<p>A generic table type used for registree data.</p>
<h3 id="tablechanges"><a class="header" href="#tablechanges"><code>TableChanges</code></a></h3>
<pre><code class="language-luau">export type TableChanges = {
    {v: any, p: {any}}
}
</code></pre>
<p>An array of changes where:</p>
<ul>
<li><code>v</code>: The new value</li>
<li><code>p</code>: The path to the value as an array</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-lua">{
    {v = 100, p = {"coins"}},
    {v = 5, p = {"level"}},
    {v = true, p = {"inventory", "sword"}}
}
</code></pre>
<h2 id="filter-types"><a class="header" href="#filter-types">Filter Types</a></h2>
<h3 id="filter"><a class="header" href="#filter"><code>Filter</code></a></h3>
<pre><code class="language-luau">export type Filter = (sender: Player?, register_key: any, tbl: Table, changes: TableChanges) -&gt; boolean
</code></pre>
<p>A function that validates changes.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>sender</code>: The player who sent the change (nil if from server)</li>
<li><code>register_key</code>: The register key being sent changes for.</li>
<li><code>tbl</code>: The old table.</li>
<li><code>changes</code>: Changes waiting to be applied.</li>
</ul>
<p><strong>Returns:</strong> <code>true</code> to accept, <code>false</code> to reject</p>
<h3 id="filterlist"><a class="header" href="#filterlist"><code>FilterList</code></a></h3>
<pre><code class="language-luau">type FilterList = {
    player_blacklist: {number}?,
    player_whitelist: {number}?,
    rate_limit: number?,
    no_recieve: boolean?,
    custom: Filter?,
}
</code></pre>
<p>Configuration object for <code>get_filter()</code>.</p>
<h2 id="interface-types"><a class="header" href="#interface-types">Interface Types</a></h2>
<h3 id="registreeinterface"><a class="header" href="#registreeinterface"><code>RegistreeInterface</code></a></h3>
<pre><code class="language-lua">export type RegistreeInterface&lt;T=Table, ReplicateArgs...=()&gt; = {
    set: (...any) -&gt; (any) -&gt; (),
    get: (...any) -&gt; any,
    incr: (...any) -&gt; (number) -&gt; (),
    replicate: (ReplicateArgs...) -&gt; (),
    full: () -&gt; T,
}
</code></pre>
<p>The proxy interface returned by the methods of <code>view().as_proxy()</code>.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>set(path: {any}, value: any) -&gt; ()</code>: Set a value at path</li>
<li><code>get(path: {any}) -&gt; any</code>: Get a value at path</li>
<li><code>incr(path: {any}, delta: number) -&gt; ()</code>: Increment a number at path</li>
<li><code>replicate(args...) -&gt; ()</code>: Replicate changes</li>
<li><code>data() -&gt; Table</code>: Get the full table</li>
</ul>
<p><strong>Server <code>replicate()</code> args:</strong> <code>{Player}?, RemoteEvent?</code>
<strong>Client <code>replicate()</code> args:</strong> <code>RemoteEvent?</code></p>
<h2 id="view"><a class="header" href="#view">View</a></h2>
<pre><code class="language-luau">export type View&lt;T = Table, ProxyType = any&gt; = {
	await: () -&gt; T,
	unwrap: () -&gt; T?,
	expect: () -&gt; T,
	as_proxy: () -&gt; {
		await: () -&gt; ProxyType,
		unwrap: () -&gt; ProxyType?,
		expect: () -&gt; ProxyType
	}
}
</code></pre>
<p>An interface for viewing non-gauranteed registree data.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>expect() -&gt; RegistreeInterface</code>: Errors if the viewed value does not exist, else returns it</li>
<li><code>unwrap() -&gt; RegistreeInterface?</code>: Returns the viewed value, regardless if it exists or not</li>
<li><code>await() -&gt; RegistreeInterface</code>: If the viewed value does not exist, then it will yield the calling thread until it does, and return it.</li>
<li><code>as_proxy() -&gt; ProxyView</code>: Returns a sub-view for viewing the registree data as proxies.</li>
</ul>
<h2 id="internal-types"><a class="header" href="#internal-types">Internal Types</a></h2>
<h3 id="registree"><a class="header" href="#registree"><code>Registree</code></a></h3>
<pre><code class="language-luau">type Registree&lt;T=Table&gt; = {
    value: T,
    copy: Table,
    filter: Filter?,
    onRecievedListeners: {(...any) -&gt; ()},
    onUpdatedListeners: {(...any) -&gt; ()},
    onKeyChangedListeners: {[string]: {(...any) -&gt; ()}}
}
</code></pre>
<p>Internal structure for registered tables.</p>
<h3 id="sender_server"><a class="header" href="#sender_server"><code>Sender_Server</code></a></h3>
<pre><code class="language-lua">type Sender_Server = (plr: Player, register_key: any, changes: TableChanges) -&gt; ()
</code></pre>
<p>Function signature for sending changes to a client.</p>
<h3 id="sender_client"><a class="header" href="#sender_client"><code>Sender_Client</code></a></h3>
<pre><code class="language-lua">type Sender_Client = (register_key: any, changes: TableChanges) -&gt; ()
</code></pre>
<p>Function signature for sending changes to the server.</p>
<h3 id="requestfull"><a class="header" href="#requestfull"><code>RequestFull</code></a></h3>
<pre><code class="language-lua">type RequestFull = (register_key: any) -&gt; TableChanges?
</code></pre>
<p>Function signature for requesting full table from server.</p>
<h2 id="callback-types"><a class="header" href="#callback-types">Callback Types</a></h2>
<h3 id="on_changes_recieved-1"><a class="header" href="#on_changes_recieved-1"><code>on_changes_recieved</code></a></h3>
<pre><code class="language-lua">(sender: Player?, register_key: any, changes: TableChanges) -&gt; 
    ("pass" | "return" | "disable", string?)
</code></pre>
<p><strong>Returns:</strong></p>
<ul>
<li><code>"pass"</code>: Continue normal processing</li>
<li><code>"return"</code>: Stop processing without applying changes</li>
<li><code>"disable"</code>: Disable this key entirely</li>
<li>Optional second return: reason string (for "disable")</li>
</ul>
<h3 id="validate_full_request-1"><a class="header" href="#validate_full_request-1"><code>validate_full_request</code></a></h3>
<pre><code class="language-lua">(player: Player, key: any) -&gt; boolean
</code></pre>
<p><strong>Returns:</strong> <code>true</code> to allow request, <code>false</code> to deny</p>
<h3 id="on_key_disabled-1"><a class="header" href="#on_key_disabled-1"><code>on_key_disabled</code></a></h3>
<pre><code class="language-lua">(register_key: any, reason: string) -&gt; ()
</code></pre>
<p>Called when a key is disabled.</p>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<pre><code class="language-lua">-- Filter function
local myFilter: Filter = function(sender, path, value)
    if path[1] == "coins" and type(value) ~= "number" then
        return false
    end
    return true
end

-- Server proxy
local serverProxy: RegistreeInterface&lt;any, ({Player}?, RemoteEvent?)&gt; = 
    ReplicatedRegistry.server.view_as_proxy("key")

serverProxy.set("coins")(100)
serverProxy.replicate({player})

-- Client proxy
local clientProxy: RegistreeInterface&lt;any, (RemoteEvent?)&gt; = 
    ReplicatedRegistry.client.view_as_proxy("key")

clientProxy.incr("level")(1)
clientProxy.replicate()

-- Changes
local changes: TableChanges = ReplicatedRegistry.get_changes("key")
for _, change in changes do
    print(`Path: {table.concat(change.p, ".")}`)
    print(`Value: {change.v}`)
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-player-data"><a class="header" href="#example-player-data">Example: Player Data</a></h1>
<p>A complete example of synchronizing player data between server and client.</p>
<h2 id="server-script"><a class="header" href="#server-script">Server Script</a></h2>
<pre><code class="language-luau">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local ReplicatedRegistry = require(ReplicatedStorage.ReplicatedRegistry2)
local server = ReplicatedRegistry.server

-- Setup remotes
server.set_remote_instances(
    ReplicatedStorage.RequestFullRemote,
    ReplicatedStorage.SendChangesRemote
)

-- Custom validation
server.callbacks.validate_full_request = function(player, key)
    -- Only allow players to access their own data
    return key == player.UserId
end

local playerDataFilter = ReplicatedRegistry.get_filter({
    rate_limit = 10, -- Max 10 updates per second
    custom = function(sender, register_key, tbl, changes)
    -- Player can only access their own keys
        if sender.UserId ~= register_key then
            return false
        end
        
        for _, c in changes do
            local value, path = c.v, c.p
            -- Prevent negative coins
            if path[1] == "coins" and type(value) == "number" and value &lt; 0 then
                return false
            end
        end
        
        return true
    end
})

Players.PlayerAdded:Connect(function(player)
    local key = player.UserId
    
    -- Create player data
    local playerData = {
        coins = 100,
        level = 1,
        inventory = {},
        settings = {
            sound = true,
            music = true
        }
    }
    
    -- Register for replication
    server.register(key, playerData, playerDataFilter)
    
    -- Listen for changes from client
    server.on_recieve(key, function(sender, tbl, changes)
        print(`Player {sender.Name} updated their data:`)
        for _, change in changes do
            print(`  {table.concat(change.p, ".")} = {change.v}`)
        end
        
        savePlayerData(sender, tbl)
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    local key = player.UserId
    local data = server.view(key)
        .expect()
    
    -- Save before player leaves
    savePlayerData(player, data)
end)

-- Example: Give coins to player
function giveCoins(player, amount)
    local proxy = server.view(player.UserId)
        .as_proxy()
        .expect()
    
    proxy.incr({"coins"}, amount)
    proxy.replicate({player}) -- Send to client
end

-- Example: Update player level
function levelUp(player)
    local data = server.view(player.UserId)
        .expect()
    
    data.level += 1
    data.coins += data.level * 10 -- Bonus coins
    
    server.to_clients(player.UserId, {player})
end
</code></pre>
<h2 id="client-script"><a class="header" href="#client-script">Client Script</a></h2>
<pre><code class="language-luau">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local ReplicatedRegistry = require(ReplicatedStorage.ReplicatedRegistry2)
local client = ReplicatedRegistry.client

-- Setup remotes
client.set_remote_instances(
    ReplicatedStorage.RequestFullRemote,
    ReplicatedStorage.SendChangesRemote
)

local player = Players.LocalPlayer
local key = player.UserId

-- Access player data
local playerData = client.view(key)
    .await()

-- Listen for updates from server
client.on_recieve(key, function(tbl, changes)
    print("Received update from server:")
    for _, change in changes do
        print(`  {table.concat(change.p, ".")} = {change.v}`)
    end
    
    -- Update UI
    updateCoinsDisplay(tbl.coins)
    updateLevelDisplay(tbl.level)
end)

-- Example: Update settings
function updateSettings(soundEnabled, musicEnabled)
    local proxy = client.view(key)
        .as_proxy()
        .expect()
    
    proxy.set({"settings", "sound"}, soundEnabled)
    proxy.set({"settings", "music"}, musicEnabled)
    
    proxy.replicate() -- Send to server
end

-- Example: Purchase item
function purchaseItem(itemName, cost)
    local data = client.view(key)
        .expect()
    
    if data.coins &gt;= cost then
        data.coins -= cost
        data.inventory[itemName] = true
        
        -- Send to server for validation
        client.to_server(key)
    else
        warn("Not enough coins!")
    end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-profilestore-integration"><a class="header" href="#example-profilestore-integration">Example: ProfileStore Integration</a></h1>
<p>Integrating ReplicatedRegistry2 with ProfileService for persistent player data.</p>
<h2 id="server-script-1"><a class="header" href="#server-script-1">Server Script</a></h2>
<pre><code class="language-lua">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Players = game:GetService("Players")

local ProfileService = require(ServerScriptService.ProfileService)
local ReplicatedRegistry = require(ReplicatedStorage.ReplicatedRegistry2)
local server = ReplicatedRegistry.server

-- Setup remotes
server.set_remote_instances(
    ReplicatedStorage.RequestFullRemote,
    ReplicatedStorage.SendChangesRemote
)

-- ProfileStore setup
local ProfileStore = ProfileService.GetProfileStore(
    "PlayerData",
    {
        coins = 0,
        level = 1,
        inventory = {},
        stats = {
            kills = 0,
            deaths = 0,
            playtime = 0
        }
    }
)

local Profiles = {}

-- Filter for player profiles
local profileFilter = ReplicatedRegistry.get_filter({
    rate_limit = 10,
    custom = function(sender, register_key, tbl, changes)
        -- Ensure player only modifies their own profile
        return register_key == sender.UserId
    end
})

Players.PlayerAdded:Connect(function(player)
    local profile = ProfileStore:LoadProfileAsync(`Player_{player.UserId}`)
    
    if not profile then
        player:Kick("Failed to load data")
        return
    end
    
    profile:AddUserId(player.UserId)
    profile:Reconcile()
    
    profile:ListenToRelease(function()
        Profiles[player] = nil
        server.deregister(player.UserId)
        player:Kick("Profile released")
    end)
    
    if not player:IsDescendantOf(Players) then
        profile:Release()
        return
    end
    
    Profiles[player] = profile
    
    -- Register profile data with ReplicatedRegistry
    local key = player.UserId
    server.register(key, profile.Data, profileFilter)
    
    -- Listen for changes from client
    server.on_receive(key, function(sender, tbl, changes)
        print(`{sender.Name} updated profile:`)
        for _, change in changes do
            print(`  {table.concat(change.p, ".")} = {change.v}`)
        end
    end)
    
    -- Periodic sync to client (every 10 seconds)
    task.spawn(function()
        while Profiles[player] do
            task.wait(10)
            if Profiles[player] then
                server.to_clients(key, {player})
            end
        end
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    local profile = Profiles[player]
    if profile then
        profile:Release()
        Profiles[player] = nil
        server.deregister(player.UserId)
    end
end)

-- Example: Give rewards
function giveReward(player, coins, xp)
    local profile = Profiles[player]
    if not profile then return end
    
    local proxy = server.view(player.UserId)
        .as_proxy()
        .expect()
    
    proxy.incr({"coins"}, coins)
    proxy.incr({"level"}, xp)
    
    -- Replicate to player
    proxy.replicate({player})
end

-- Example: Add item to inventory
function giveItem(player, itemName)
    local profile = Profiles[player]
    if not profile then return end
    
    local data = server.view(player.UserId)
        .expect()
    data.inventory[itemName] = true
    
    server.to_clients(player.UserId, {player})
end

-- Example: Update stats
function recordKill(player)
    local profile = Profiles[player]
    if not profile then return end
    
    local proxy = server.view(player.UserId)
        .as_proxy()
        .expect()
    proxy.incr({"stats", "kills"}, 1)
    proxy.replicate({player})
end
</code></pre>
<h2 id="client-script-1"><a class="header" href="#client-script-1">Client Script</a></h2>
<pre><code class="language-luau">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local ReplicatedRegistry = require(ReplicatedStorage.ReplicatedRegistry2)
local client = ReplicatedRegistry.client

-- Setup remotes
client.set_remote_instances(
    ReplicatedStorage.RequestFullRemote,
    ReplicatedStorage.SendChangesRemote
)

local player = Players.LocalPlayer
local key = player.UserId

-- Wait for data to be ready
local playerData = client.view(key)
    .await()

-- Listen for profile updates
client.on_receive(key, function(tbl, changes)
    for _, change in changes do
        local path = table.concat(change.p, ".")
        print(`Profile updated: {path} = {change.v}`)
        
        -- Update UI based on what changed
        if change.p[1] == "coins" then
            updateCoinsUI(tbl.coins)
        elseif change.p[1] == "level" then
            updateLevelUI(tbl.level)
        elseif change.p[1] == "stats" then
            updateStatsUI(tbl.stats)
        end
    end
end)

-- Initial UI setup
updateCoinsUI(playerData.coins)
updateLevelUI(playerData.level)
updateStatsUI(playerData.stats)

-- Example: Purchase system
function tryPurchase(itemName, cost)
    local data = client.view(key)
        .expect()
    
    if data.coins &gt;= cost then
        -- Optimistic update
        data.coins -= cost
        data.inventory[itemName] = true
        
        -- Server will validate
        ReplicatedRegistry.client.to_server(key)
        return true
    end
    
    return false
end
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>ProfileStore handles persistence</li>
<li>ReplicatedRegistry handles real-time sync</li>
<li>Server validates all client changes</li>
<li>Client gets immediate feedback with optimistic updates</li>
<li>Profile data automatically reconciles on load</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-shared-data"><a class="header" href="#example-shared-data">Example: Shared Data</a></h1>
<p>Examples of using ReplicatedRegistry2 for shared game state like leaderboards and settings.</p>
<h2 id="global-leaderboard"><a class="header" href="#global-leaderboard">Global Leaderboard</a></h2>
<h3 id="server"><a class="header" href="#server">Server</a></h3>
<pre><code class="language-luau">local ReplicatedRegistry = require(ReplicatedStorage.ReplicatedRegistry2)
local server = ReplicatedRegistry.server

-- Setup remotes
server.set_remote_instances(
    ReplicatedStorage.RequestFullRemote,
    ReplicatedStorage.SendChangesRemote
)

-- Create global leaderboard
local leaderboard = {
    topPlayers = {},
    lastUpdate = os.time()
}

server.register("global_leaderboard", leaderboard, 
    ReplicatedRegistry.get_filter {no_recieve = true})

-- Update leaderboard
function updateLeaderboard()
    local proxy = server.view("global_leaderboard")
        .as_proxy()
        .expect()
    -- Sort players by score
    local players = {}
    for _, player in Players:GetPlayers() do
        table.insert(players, {
            name = player.Name,
            userId = player.UserId,
            score = getPlayerScore(player)
        })
    end
    
    table.sort(players, function(a, b)
        return a.score &gt; b.score
    end)
    
    -- Take top 10
    local top10 = {}
    for i = 1, math.min(10, #players) do
        top10[i] = players[i]
    end
    
    proxy.set({"topPlayers"}, top10)
    proxy.set({"lastUpdate"}, os.time())
    
    -- Broadcast to all players
    proxy.replicate(game.Players:GetPlayers())
end

-- Update every 30 seconds
task.spawn(function()
    while true do
        task.wait(30)
        updateLeaderboard()
    end
end)
</code></pre>
<h3 id="client"><a class="header" href="#client">Client</a></h3>
<pre><code class="language-luau">local ReplicatedRegistry = require(ReplicatedStorage.ReplicatedRegistry2)
local client = ReplicatedRegistry.client

client.set_remote_instances(
    ReplicatedStorage.RequestFullRemote,
    ReplicatedStorage.SendChangesRemote
)

-- Get leaderboard
local leaderboard = client.view("global_leaderboard")
    .await()

-- Listen for updates
client.on_update("global_leaderboard", function(tbl)
    print("Leaderboard updated!")
    updateLeaderboardUI(tbl.topPlayers)
end)

-- Initial display
updateLeaderboardUI(leaderboard.topPlayers)
</code></pre>
<h2 id="game-settings"><a class="header" href="#game-settings">Game Settings</a></h2>
<h3 id="server-1"><a class="header" href="#server-1">Server</a></h3>
<pre><code class="language-luau">local ReplicatedRegistry = require(ReplicatedStorage.ReplicatedRegistry2)
local server = ReplicatedRegistry.server

-- Setup remotes
server.set_remote_instances(
    ReplicatedStorage.RequestFullRemote,
    ReplicatedStorage.SendChangesRemote
)

-- Game settings
local gameSettings = {
    maxPlayers = 16,
    roundTime = 300,
    gameMode = "FFA",
    mapName = "Arena1",
    friendly_fire = false
}

-- Only admins can modify
local adminFilter = ReplicatedRegistry.get_filter({
    player_whitelist = {123456, 789012}, -- Admin user IDs
    rate_limit = 5
})

server.register("game_settings", gameSettings, adminFilter)

-- Listen for admin changes
server.on_receive("game_settings", function(sender, tbl, changes)
    print(`Admin {sender.Name} changed settings:`)
    for _, change in changes do
        print(`  {table.concat(change.p, ".")} = {change.v}`)
    end
    
    -- Broadcast to all players
    server.to_clients(
        "game_settings",
        Players:GetPlayers()
    )
end)

-- Helper function to update settings
function updateGameSettings(newSettings)
    local proxy = server.view("game_settings")
        .as_proxy()
        .expect()
    for key, value in newSettings do
        proxy.set({key}, value)
    end
    
    -- Broadcast to everyone
    proxy.replicate(Players:GetPlayers())
end
</code></pre>
<h3 id="client-1"><a class="header" href="#client-1">Client</a></h3>
<pre><code class="language-luau">local ReplicatedRegistry = require(ReplicatedStorage.ReplicatedRegistry2)
local client = ReplicatedRegistry.client

client.set_remote_instances(
    ReplicatedStorage.RequestFullRemote,
    ReplicatedStorage.SendChangesRemote
)

-- Get settings
local settings = client.view("game_settings")
    .await()

-- Listen for changes
client.on_receive("game_settings", function(tbl, changes)
    print("Game settings updated:")
    for _, change in changes do
        local setting = change.p[1]
        local value = change.v
        print(`  {setting} = {value}`)
        
        -- Update UI or game logic
        if setting == "roundTime" then
            updateTimerUI(value)
        elseif setting == "gameMode" then
            updateGameMode(value)
        end
    end
end)

-- Admin panel (only works if player is whitelisted)
function isAdmin(player)
    -- Check if player is admin
    return table.find({123456, 789012}, player.UserId) ~= nil
end

if isAdmin(Players.LocalPlayer) then
    -- Admin can change settings
    function changeRoundTime(newTime)
        local proxy = client.view("game_settings")
            .as_proxy()
            .expect()
        proxy.set({"roundTime"}, newTime)
        proxy.replicate()
    end
end
</code></pre>
<h2 id="team-data"><a class="header" href="#team-data">Team Data</a></h2>
<h3 id="server-2"><a class="header" href="#server-2">Server</a></h3>
<pre><code class="language-luau">local teams = {
    red = {
        score = 0,
        players = 0,
        color = Color3.fromRGB(255, 0, 0)
    },
    blue = {
        score = 0,
        players = 0,
        color = Color3.fromRGB(0, 0, 255)
    }
}

-- Allow server updates only
local filter = ReplicatedRegistry.get_filter({
    no_recieve = true -- No client updates
})

server.register("team_data", teams, filter)

-- Update team scores
function addTeamScore(teamName, points)
    local proxy = server.view("team_data")
        .as_proxy()
        .expect()
    
    proxy.incr({teamName, "score"}, points)
    proxy.replicate(Players:GetPlayers()) -- Broadcast to all
end

-- Update player counts
Players.PlayerAdded:Connect(function(player)
    local team = getPlayerTeam(player)
    local proxy = server.view("team_data")
        .as_proxy()
        .expect()
    
    proxy.incr({team, "players"}, 1)
    proxy.replicate(Players:GetPlayers())
end)
</code></pre>
<h3 id="client-2"><a class="header" href="#client-2">Client</a></h3>
<pre><code class="language-lua">local teams = client.view("team_data")

-- Update UI when teams change
client.on_update("team_data", function(tbl)
    updateTeamScoreUI(tbl.red.score, tbl.blue.score)
    updateTeamCountUI(tbl.red.players, tbl.blue.players)
end)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
